\documentclass{article}

\begin{document}
    \title{\textbf{Epsilon to Verilog}\\[0.5cm] \large EE677 Course Project}
    \author{Anay Joshi 09007019\\Savant Krishna 100070056}
    \maketitle
    \newpage
    \section{Introduction}
        Epsilon is a custom high level language developed to assist in high level synthesis. For more details on epsilon, refer to documentation of epsilon. This document explains how Verilog backend to Epsilon is created, how to create a custom backend and what other future modifications are possible. The Verilog backend implemented is a minimalistic one with each instruction of the control flow graph (cfg) considered as a state.
    
    \section{Implementation}
        This section explains the details of the implementation of the Verilog backend. The control flow graph dumped by epsilon is accessed and analyzed to create the resulting verilog. The cfg consists of various basic blocks, each containing any number of instructions with a conditional or unconditional jump instructions to other basic blocks. In case a basic block does not have any jump instructions, it is probably the last state corresponding to return instruction.
        Every basic block object has following attributes 
        \begin{verbatim}
        
        number_of_instructions
            instruction_list
        condition
        condition_instr
        number_of_children
        child_true
        child_false
        child
        identity
        
        \end{verbatim} which help recognize the number of instructions and the kind of jump statements in it. \\Each instruction in the basic block is a state in itself with the basic block itself being a state(representing the jump instruction). Whenever the control jumps to a basic block, the state is changed to the state of the first instruction in it. If there are no instructions in the basic block, the state is changed to that represented by the basic block's jump instruction. When in the final instruction of a basic block, the state jumps to that of the basic block (JmpInstruction). When current state corresponds to the (JmpInstruction) basic block, depending on whether the jump is conditional or unconditional corresponding state transition is made. The states are numbered in the order of identity of the basic blocks, each instruction of every basic block being given a state number in the order of instructions in the list 'instruction\_list'.\\ The data flow path is as explained below. Each variable which is loaded a value in any of the instructions is allocated a 32-bit register (from the beginning to the end). These registers are multiplexed (controlled by the state diagram) so that they are updated as and when required. The operators are combinational blocks whose inputs are multiplexed according to the state variable to calculate the required variables. The module takes in a clock, reset pin and gives out a outReady signal. The reset pin when low resets the state machine to the start state, which is generally the first basic block or the first instruction in the first basic block. The outReady is HIGH when the state machine reaches the final state from which there is no child (i.e, no JmpInstruction). It signifies that the output is ready and the function evaluation is over. It corresponds to the return statement in the epsilon program.
        A testbench is also implemented which instantiates the main module, takes the inputs from user and displays the final result after simulating the resulting verilog file.

    \section{Improvements and future scope}
        The verilog backend is a minimalistic proof of concept implementation. It can be improved using different algorithms for scheduling, resource allocation and binding. A new backend can also be created on the similar lines.
        There is almost no amount of parallelization in the current verilog backend implementation. Instructions are done sequentially and Variables are considered alive for the whole time in this implementation. One way to improve the efficiency is to schedule so that independent instructions can occur simultaneously using many resources. Another way is to have efficient memory use by determining variable lives and reallocating registers with dead variables (variables which are not accessed ) to other new variables. Variables are bound to specific registers for their lifetime, which can be figured out from the control flow graph. One more problem which should be addressed when parellizing the computation is the resource constriant. In case the hardware is resource constrained, for eg. if there can only be 3 adders possible, then suitable scheduling needs to be done to strike the balance between resources needed and the time taken for the computation.
\end{document}
